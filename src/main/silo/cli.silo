
package(silo.cli)
import(silo.core)

alias(Runtime, silo.lang.Runtime)
alias(CompilationContext, silo.lang.CompilationContext)
alias(FileUtils, org.apache.commons.io.FileUtils)
alias(FilenameUtils, org.apache.commons.io.FilenameUtils)

alias(Console, org.jboss.jreadline.console.Console)
alias(ConsoleOutput, org.jboss.jreadline.console.ConsoleOutput)

func(main(args : Vector) {
    if(args#length() == 0 {
        // TODO: Perhaps enter a REPL?
        //println(help(null))
        shell()
        return()
    })

    first : Object = args#nth(0, null)

    if(first#equals("run") {
        run(args#nth(1, null))
    } else(first#equals("shell")) {
        shell()
    } else(first#equals("compile")) {
        compile(args#nth(1, null))
    } else(first#equals("help")) {
        println(help(args#nth(1, null)))
    } else(first#equals("version")) {
        println(version())
    } else(first#equals("copyright")) {
        println(copyright())
    } else {
        run(args#nth(0, null))
    })
})

func(run(file_ : Object) {
    if(file_ {
        file : String = file_#toString();
    } else {
        return
    })

    source : String = FileUtils.readFileToString(File(file))
    code : silo.lang.Node = silo.lang.compiler.Parser.parse(file, source)

    runtime : Runtime = Runtime();
    classes : java.util.Vector = runtime#compile(code)

    c : Class = checkcast(classes#get(classes#size() - 1), java.lang.Class)
    f : Function = checkcast(c#newInstance(), Function)

    a : silo.lang.Actor = runtime#spawn(f)
    a#await()

    runtime#shutdown()
})

func(shell {
    console : Console = Console();

    println(version() + "\n")

    line : ConsoleOutput = null;
    while(line = console#read("> ") {
        console#pushToStdOut(line#getBuffer() + "\n\n");

        if(line#getBuffer() == "quit" || line#getBuffer() == "exit" {
            break
        })
    })
})

func(compile(file_ : Object) {
    if(file_ {
        file : String = file_#toString();
    } else {
        return
    })

    source : String = FileUtils.readFileToString(File(file))
    code : silo.lang.Node = silo.lang.compiler.Parser.parse(file, source)

    runtime : Runtime = Runtime();
    context : CompilationContext = runtime#contextByCompiling(source)

    i : int = 0
    while(i < invokevirtual(context.bytecode, size()) {
        bytecode : array(byte) = checkcast(invokevirtual(context.bytecode, get(i)), array(byte))
        silo.lang.Compile.writeBytecodeToDirectory(bytecode, FilenameUtils.removeExtension(file))

        i = i + 1
    })
})

func(version {
    String.format("Silo %s (Codename: %s) - %s, %s.", silo.lang.Version.string, silo.lang.Version.codename, System.getProperty("java.vm.name"), System.getProperty("java.version"))
})

func(copyright() {
    String.format("%s - %s", version(), "Copyright (c) 2014 by Salman Ahmad")
})

func(help(command) {
    if(!command, command = "")

    if(command#equals("run") {
"
Usage: silo [run] FILES

  Run a Silo program. If files lists raw '.silo' files they will be compiled
  and dynamically executed. If a '.jar' file is present it will be run instead.
"
    } else(command#equals("compile")) {
"
Usage: silo compile [options] [FILES]

  Compile a Silo source files and output JVM bytecode.


Options include:
  --all                 # Compile all of the files in the current directory.
                        # This option causes '--output' to default to the
                        # current directory. This means that .class
                        # files will appear in the current directory.

  [--jar | --classes]   # Output a single .jar file or individual java .class
                        # files. The jar file can be directly executed using
                        # the 'silo run' command. The default is --jar.

  --output NAME         # The name of the .jar file or the location to place
                        # the .class files. If .jar is used and a directory is
                        # specified, the name of the jar file will match the
                        # name of the directory. This option will default to
                        # the name of the first file listed or the current
                        # directory if --all is specified.

  --show-bytecode       # Print the compiled byte code. Useful for
                        # debugging purposes.
"
    } else(command#equals("shell")) {

"
Usage: silo [shell]

  Launch an interactive REPL (read-evaluate-print-loop) that allows you to type
  and execute Silo commands directly into your terminal.
"

    } else(command#equals("version")) {
"
Usage: silo version

  Show Silo version.
"
    } else(command#equals("copyright")) {
"
Usage: silo copyright

  Show Silo copyright.
"
    } else {
"
Usage: silo [COMMAND] [command-specific-arguments]

List of commands, type \"silo help COMMAND\" for more details:

  run         # Run a Silo program
  shell       # Launch the interactive Silo shell
  compile     # Compile Silo source files and output JVM bytecode
  help        # Show the help page for a command
  version     # Show the Silo version
  copyright   # Show the Silo copyright
"
    })
})