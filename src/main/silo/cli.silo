
package(silo.cli)
import(silo.core)

alias(Runtime, silo.lang.Runtime)
alias(CompilationContext, silo.lang.CompilationContext)
alias(FileUtils, org.apache.commons.io.FileUtils)
alias(FilenameUtils, org.apache.commons.io.FilenameUtils)

alias(Actor, silo.lang.Actor)
alias(Node, silo.lang.Node)
alias(Symbol, silo.lang.Symbol)
alias(Compiler, silo.lang.compiler.Compiler)
alias(Parser, silo.lang.compiler.Parser)

alias(ConsoleReader, jline.console.ConsoleReader)
alias(Completer, jline.console.completer.Completer)
alias(FileNameCompleter, jline.console.completer.FileNameCompleter)
alias(StringsCompleter, jline.console.completer.StringsCompleter)

alias(JavaVector, java.util.Vector)

func(main(args : Vector) {
    if(args#length() == 0 {
        // TODO: Perhaps enter a REPL?
        //println(help(null))
        shell()
        return()
    })

    first : Object = args#nth(0, null)

    if(first#equals("run") {
        run(args#nth(1, null))
    } else(first#equals("shell")) {
        shell()
    } else(first#equals("compile")) {
        compile(args#nth(1, null))
    } else(first#equals("help")) {
        println(help(args#nth(1, null)))
    } else(first#equals("version")) {
        println(version())
    } else(first#equals("copyright")) {
        println(copyright())
    } else {
        run(args#nth(0, null))
    })
})

func(run(file_ : Object) {
    if(file_ {
        file : String = file_#toString();
    } else {
        return
    })

    source : String = FileUtils.readFileToString(File(file))
    code : silo.lang.Node = silo.lang.compiler.Parser.parse(file, source)

    runtime : Runtime = Runtime();
    classes : java.util.Vector = runtime#compile(code)

    c : Class = checkcast(classes#get(classes#size() - 1), java.lang.Class)
    f : Function = checkcast(c#newInstance(), Function)

    a : silo.lang.Actor = runtime#spawn(f)
    a#await()

    runtime#shutdown()
})

func(processLocals(code : Object, locals : Map, processFunctions : boolean => Vector) {
    if(instanceof(code Symbol) {
        if(map.get(locals, code) {
            t : Object = map.get(locals, code)

            functionName : Object = Parser.parse("silo.cli.getLocal")#getFirstChild()
            code = Node.fromVector(
                vector.create(
                    Symbol("checkcast")
                    Node.fromVector(
                        vector.create(
                            functionName
                            code#toString()
                        )
                    )
                    Parser.parse(t#toString())#getFirstChild()
                )
            )
        })

        return(vector.create(code, locals))
    } else(instanceof(code Node)) {
        v : Vector = null

        node : Node = checkcast(code, Node)
        label : Object = node#getLabel()

        if(label == Symbol("function") && !processFunctions {
            // Do not recurse any more
            return(vector.create(code, locals))
        })

        if(label == Symbol("=") {
            // Assigning a local variable
            first : Object = node#getFirstChild()
            second : Object = node#getSecondChild()

            functionName : Object = Parser.parse("silo.cli.setLocal")#getFirstChild()

            v = processLocals(second, locals, false)
            second = vector.get(v, 0)
            locals = checkcast(vector.get(v, 1), Map)

            if(instanceof(first Node) && (checkcast(first Node)#getLabel() == Symbol(":")) {
                n : Node = checkcast(first, Node)

                locals = map.set(locals, n#getFirstChild(), n#getSecondChild()#toString())

                code = Node.fromVector(
                    vector.create(
                        functionName
                        n#getFirstChild()#toString()
                        second
                    )
                )

                return(vector.create(code locals))
            } else(instanceof(first, Symbol)) {
                locals = map.set(locals, first, Parser.parse("java.lang.Object")#getFirstChild())
                code = Node.fromVector(
                    vector.create(
                        functionName
                        first#toString()
                        second
                    )
                )

                return(vector.create(code locals))
            } else {
                v = processLocals(first, locals, false)
                first = vector.get(v, 0)
                locals = checkcast(vector.get(v, 1), Map)

                return(vector.create(Node.fromVector(
                    vector.create(
                        Symbol("=")
                        first
                        second
                    )
                ) locals))
            })
        })

        v = processLocals(label, locals, false);
        label = vector.get(v, 0)
        locals = checkcast(vector.get(v, 1), Map)

        nodeContent : Vector = vector.create()
        nodeContent = vector.push(nodeContent, label)

        i : int = 0
        children : JavaVector = node#getChildren()
        while(i < children#size() {
            child : Object = children#get(i)
            v = processLocals(child, locals, false)

            child = vector.get(v, 0)
            locals = checkcast(vector.get(v, 1), Map)
            nodeContent = vector.push(nodeContent, child)

            i = i + 1
        })

        return(vector.create(Node.fromVector(nodeContent), locals))
    } else {
        return(vector.create(code, locals))
    })

    null
})

func(shell {
    runtime : Runtime = Runtime()

    // TODO: Explore more features of jLine. Examples are here:
    // https://github.com/jline/jline2/blob/master/src/test/java/jline/example/Example.java
    // In particular, it would be nice to support color, multi-line inputs, and API completion
    // Multi-line edits are actually somewhat simple. I should just count the number of unbalanced
    // parens and braces and then go into multiline mode. I should end when the parens are balanced.
    console : ConsoleReader = ConsoleReader()
    console#setPrompt("> ")

    locals : Map = map.create()

    println(version() + "\n")

    line : String = null
    while(line = console#readLine() {
        if(line == "quit" || line == "exit" {
            break
        })

        try({
            code : Object = Parser.parse(line)
            code = runtime#expandCode(code)

            v : Vector = processLocals(code, locals, true)
            code = vector.get(v, 0)
            locals = checkcast(vector.get(v, 1), Map)

            classes : JavaVector = runtime#compileExpandedCode(code)

            f : Function = checkcast(checkcast(classes#get(classes#size() - 1), Class)#newInstance() Function)
            actor : Actor = runtime#spawn(f)
            output : Object = actor#await()

            println(output + "\n")
        } catch(e : Exception) {
            e#printStackTrace()
        })
    })
})

func(compile(file_ : Object) {
    if(file_ {
        file : String = file_#toString();
    } else {
        return
    })

    source : String = FileUtils.readFileToString(File(file))
    code : silo.lang.Node = silo.lang.compiler.Parser.parse(file, source)

    runtime : Runtime = Runtime();
    context : CompilationContext = runtime#contextByCompiling(source)

    i : int = 0
    while(i < invokevirtual(context.bytecode, size()) {
        bytecode : array(byte) = checkcast(invokevirtual(context.bytecode, get(i)), array(byte))
        silo.lang.Compile.writeBytecodeToDirectory(bytecode, FilenameUtils.removeExtension(file))

        i = i + 1
    })
})

func(version {
    String.format("Silo %s (Codename: %s) - %s, %s.", silo.lang.Version.string, silo.lang.Version.codename, System.getProperty("java.vm.name"), System.getProperty("java.version"))
})

func(copyright() {
    String.format("%s - %s", version(), "Copyright (c) 2014 by Salman Ahmad")
})

func(help(command) {
    if(!command, command = "")

    if(command#equals("run") {
"
Usage: silo [run] FILES

  Run a Silo program. If files lists raw '.silo' files they will be compiled
  and dynamically executed. If a '.jar' file is present it will be run instead.
"
    } else(command#equals("compile")) {
"
Usage: silo compile [options] [FILES]

  Compile a Silo source files and output JVM bytecode.


Options include:
  --all                 # Compile all of the files in the current directory.
                        # This option causes '--output' to default to the
                        # current directory. This means that .class
                        # files will appear in the current directory.

  [--jar | --classes]   # Output a single .jar file or individual java .class
                        # files. The jar file can be directly executed using
                        # the 'silo run' command. The default is --jar.

  --output NAME         # The name of the .jar file or the location to place
                        # the .class files. If .jar is used and a directory is
                        # specified, the name of the jar file will match the
                        # name of the directory. This option will default to
                        # the name of the first file listed or the current
                        # directory if --all is specified.

  --show-bytecode       # Print the compiled byte code. Useful for
                        # debugging purposes.
"
    } else(command#equals("shell")) {

"
Usage: silo [shell]

  Launch an interactive REPL (read-evaluate-print-loop) that allows you to type
  and execute Silo commands directly into your terminal.
"

    } else(command#equals("version")) {
"
Usage: silo version

  Show Silo version.
"
    } else(command#equals("copyright")) {
"
Usage: silo copyright

  Show Silo copyright.
"
    } else {
"
Usage: silo [COMMAND] [command-specific-arguments]

List of commands, type \"silo help COMMAND\" for more details:

  run         # Run a Silo program
  shell       # Launch the interactive Silo shell
  compile     # Compile Silo source files and output JVM bytecode
  help        # Show the help page for a command
  version     # Show the Silo version
  copyright   # Show the Silo copyright
"
    })
})