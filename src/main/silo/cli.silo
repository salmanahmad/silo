
package(silo.cli)
import(silo.core)

alias(Runtime, silo.lang.Runtime)
alias(FileUtils, org.apache.commons.io.FileUtils)

func(main(args : IPersistentVector) {
    if(args#length() == 0 {
        // TODO: Perhaps enter a REPL?
        println(help(null))
        return()
    })

    first : Object = args#nth(0, null)

    if(first#equals("run") {
        run(args#nth(1, null))
    } else(first#equals("compile")) {
        compile(args#nth(1, null))
    } else(first#equals("help")) {
        println(help(args#nth(1, null)))
    } else(first#equals("version")) {
        println(version())
    } else(first#equals("copyright")) {
        println(copyright())
    } else {
        run(args#nth(0, null))
    })
})

func(run(file_ : Object) {
    if(file_ {
        file : String = file_#toString();
    } else {
        return
    })

    runtime : Runtime = Runtime();
    source : String = FileUtils.readFileToString(File(file))
    code : silo.lang.Node = silo.lang.compiler.Parser.parse(source)
    
    classes : Vector = null
    runtime#compile(code)
    //runtime#eval(classes#get(classes#size() - 1))
})

func(compile(file_ : Object) {
    println("Compile is not implemented yet!")
})

func(version {
    String.format("Silo %s (Codename: %s)", silo.lang.Version.string, silo.lang.Version.codename)
})

func(copyright() {
    String.format("%s - %s", version(), "Copyright (c) 2014 Salman Ahmad")
})

func(help(command) {
    if(!command, command = "")

    if(command#equals("run") {
"
Usage: silo run [FILES]

  Run a Silo program. If files lists raw '.silo' files they will be compiled
  and dynamically executed. If a '.jar' file is present it will be run instead.
"
    } else(command#equals("compile")) {
"
Usage: silo compile [options] [FILES]

  Compile a Silo source files and output JVM bytecode.


Options include:
  --all                 # Compile all of the files in the current directory.
                        # This option causes '--output' to default to the
                        # current directory. This means that .class
                        # files will appear in the current directory.

  [--jar | --classes]   # Output a single .jar file or individual java .class
                        # files. The jar file can be directly executed using
                        # the 'silo run' command. The default is --jar.

  --output NAME         # The name of the .jar file or the location to place
                        # the .class files. If .jar is used and a directory is
                        # specified, the name of the jar file will match the
                        # name of the directory. This option will default to
                        # the name of the first file listed or the current
                        # directory if --all is specified.

  --show-bytecode       # Print the compiled byte code. Useful for
                        # debugging purposes.
"
    } else(command#equals("version")) {
"
Usage: silo version

  Show Silo version.
"
    } else(command#equals("copyright")) {
"
Usage: silo copyright

  Show Silo copyright.
"
    } else {
"
Usage: silo COMMAND [command-specific-arguments]

List of commands, type \"silo help COMMAND\" for more details:

  run         # Run a Silo program
  compile     # Compile Silo source files and output JVM bytecode
  help        # Show the help page for a command
  version     # Show the Silo version
  copyright   # Show the Silo copyright
"
    })
})