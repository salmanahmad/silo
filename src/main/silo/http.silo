
package(silo.net.http.connection {
    alias(DefaultFullHttpResponse, io.netty.handler.codec.http.DefaultFullHttpResponse)
    alias(DefaultHttpResponse, io.netty.handler.codec.http.DefaultHttpResponse)
    alias(DefaultHttpContent, io.netty.handler.codec.http.DefaultHttpContent)
    alias(LastHttpContent, io.netty.handler.codec.http.LastHttpContent)

    alias(HttpVersion, io.netty.handler.codec.http.HttpVersion)
    alias(HttpResponseStatus, io.netty.handler.codec.http.HttpResponseStatus)

    alias(ByteBuf, io.netty.buffer.ByteBuf)
    alias(CharsetUtil, io.netty.util.CharsetUtil)
    alias(Unpooled, io.netty.buffer.Unpooled)

    func(close(c : Connection) {
        throw("Unimplemented Close")
    })

    func(read(c : Connection => HttpContentMessage) {
        if(c.doneReading {
            return(null)
        })

        while(true {
            o : Object = actor.peek()

            if(instanceof(HttpContentMessage, o) {
                message : HttpContentMessage = checkcast(HttpContentMessage, o)
                if(message.connectionId == c.connectionId {
                    actor.read()

                    if(message.lastHttpMessage {
                        c.doneReading = true
                    })

                    return(message);
                })
            })

            actor.skip()
        })

        return(null);
    })

    func(readAll(c : Connection => String) {
        buffer : StringBuilder = StringBuilder()

        while(true {
            message : HttpContentMessage = read(c)
            buffer#append(message.content#toString())

            if(message.lastHttpMessage {
                break
            })
        })

        buffer#toString()
    })

    func(writeHead(c : Connection, status : int, headers : Map) {
        if(c.doneWriting {
            return(null)
        })

        // TODO: Support Headers

        response : DefaultHttpResponse = DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(status))

        c.context#write(response)

        null
    })

    func(write(c : Connection, message : Object) {
        if(c.doneWriting {
            return(null)
        })

        content = null

        if(instanceof(ByteBuf, message) {
            content = DefaultHttpContent(checkcast(ByteBuf, message))
        } else {
            content = DefaultHttpContent(Unpooled.copiedBuffer(message#toString(), CharsetUtil.UTF_8))
        })

        c.context#write(content)

        null
    })

    func(writeEnd(c : Connection, trailers : Map) {
        if(c.doneWriting {
            return(null)
        } else {
            c.doneWriting = true
        })

        if(trailers == null {
            c.context#writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT)
        } else {
            throw("Trailers Unimplemented")
        })

        null
    })

    func(writeAll(c : Connection, status : int, headers : Map, message : Object) {
        if(c.doneWriting {
            return(null)
        } else {
            c.doneWriting = true
        })

        if((!instanceof(ByteBuf, message)) {
            message = Unpooled.copiedBuffer(message#toString(), CharsetUtil.UTF_8)
        })

        data : ByteBuf = checkcast(ByteBuf, message)
        response : DefaultFullHttpResponse = DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(status), data)
        invokevirtual(response#headers(), set(checkcast(CharSequence, "Content-Length"), Integer(data#readableBytes())))
        invokevirtual(response#headers(), set(checkcast(CharSequence, "Connection"), "keep-alive"))

        c.context#writeAndFlush(response)

        null
    })
})
