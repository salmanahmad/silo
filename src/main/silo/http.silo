
package(silo.net.http.connection {
    alias(DefaultFullHttpResponse, io.netty.handler.codec.http.DefaultFullHttpResponse)
    alias(DefaultHttpResponse, io.netty.handler.codec.http.DefaultHttpResponse)
    alias(DefaultHttpContent, io.netty.handler.codec.http.DefaultHttpContent)
    alias(LastHttpContent, io.netty.handler.codec.http.LastHttpContent)

    alias(HttpVersion, io.netty.handler.codec.http.HttpVersion)
    alias(HttpResponseStatus, io.netty.handler.codec.http.HttpResponseStatus)

    alias(ByteBuf, io.netty.buffer.ByteBuf)
    alias(CharsetUtil, io.netty.util.CharsetUtil)
    alias(Unpooled, io.netty.buffer.Unpooled)

    func(handle(f : Function, r : Request, c : Connection) {
        try({
            f(r, c)
        } finally {
            if(!checkcast(map.get(r.headers, "Connection", "Close"), String)#equalsIgnoreCase("Keep-Alive") {
                close(c)
            })
        })
    })

    func(close(c : Connection) {
        if(c.closed {
            return(null)
        })

        c.doneReading = true
        c.doneWriting = true
        c.closed = true

        c.context#close()
    })

    func(readHead(c : Connection => Response) {
        if(c.type == Connection.SERVER {
            // A client connection cannot be given another header
            return(null)
        })

        return(null)
    })

    func(read(c : Connection => HttpContentMessage) {
        if(c.doneReading {
            return(null)
        })

        while(true {
            o : Object = actor.peek()

            if(instanceof(o, HttpContentMessage) {
                message : HttpContentMessage = checkcast(o, HttpContentMessage)
                if(message.connectionId == c.connectionId {
                    actor.read()

                    if(message.lastHttpMessage {
                        c.doneReading = true
                    })

                    return(message);
                })
            })

            actor.skip()
        })

        return(null);
    })

    func(readAll(c : Connection => HttpContentMessage) {
        buffer : ByteBuf = null

        while(true {
            message : HttpContentMessage = read(c)

            if(buffer == null {
                buffer = message.content
            } else {
                buffer = Unpooled.wrappedBuffer(buffer, message.content)
            })

            if(message.lastHttpMessage {
                message.content = buffer
                return(message)
            })
        })

        null
    })

    func(writeContinue(c : Connection) {
        response : DefaultFullHttpResponse = DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE)
        c.context#writeAndFlush(response)

        null
    })

    func(writeHead(c : Connection, status : int, headers : Map) {
        if(c.type == Connection.CLIENT {
            // A client connection cannot be given another header
            return(null)
        })

        if(c.doneWriting {
            return(null)
        })

        // TODO: Support Headers

        response : DefaultHttpResponse = DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(status))

        c.context#write(response)

        null
    })

    func(write(c : Connection, message : Object) {
        if(c.doneWriting {
            return(null)
        })

        content = null

        if(instanceof(message, ByteBuf) {
            content = DefaultHttpContent(checkcast(message, ByteBuf))
        } else {
            content = DefaultHttpContent(Unpooled.copiedBuffer(message#toString(), CharsetUtil.UTF_8))
        })

        c.context#write(content)

        null
    })

    func(writeEnd(c : Connection, trailers : Map) {
        if(c.doneWriting {
            return(null)
        } else {
            c.doneWriting = true
        })

        if(trailers == null {
            c.context#writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT)
        } else {
            throw("Trailers Unimplemented")
        })

        null
    })

    func(writeAll(c : Connection, status : int, headers : Map, message : Object) {
        if(c.doneWriting {
            return(null)
        } else {
            c.doneWriting = true
        })

        if((!instanceof(message, ByteBuf)) {
            message = Unpooled.copiedBuffer(message#toString(), CharsetUtil.UTF_8)
        })

        data : ByteBuf = checkcast(message, ByteBuf)
        response : DefaultFullHttpResponse = DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(status), data)
        invokevirtual(response#headers(), set(checkcast("Content-Length", CharSequence), Integer(data#readableBytes())))

        if(c.isKeepAlive {
            response#headers()#set("Connection", "Keep-Alive")
        } else {
            response#headers()#set("Connection", "Close")
        })

        c.context#writeAndFlush(response)

        null
    })
})
