
package(silo.core)

alias(Compiler, silo.lang.compiler.Compiler)
alias(Symbol, silo.lang.Symbol)
alias(Node, silo.lang.Node)
alias(Structure, silo.lang.Structure)
alias(CompilationContext, silo.lang.CompilationContext)
alias(DefineClass, silo.lang.expressions.DefineClass)

macro(comment(body ...) {
    return(null)
})

// Note: this is a  macro and not a function
transform(assert(value, reason) {
    try({
        if(!value {
            throw(reason)
        })
    } catch(escape(uniquesymbol()) : Exception) {
        throw(reason)
    })
})

transform(for(init, condition, end, body) {
    init
    while(condition {
        body
        end
    })
})

//type(User {
//    name : String
//    id : int
//} Readable {
//    read() {
//        
//    }
//})

macro(type(typeName : Symbol, body : Node) {
    context : CompilationContext = silo.lang.compiler.Compiler.getCurrentCompilationContext()

    output : Vector = vector.create(
        quote(defineclass)
        quote(name(escape(typeName)))
        quote(extends(silo.lang.Structure))
        quote(constructor(modifiers(public){}))
    )

    ctorInputs : Vector = vector.create(quote(inputs))
    ctorBody : Vector = vector.create(null)

    children : java.util.Vector = body#getChildren();
    for(i : int = 0; i < children#size(); i = i + 1 {
        name : Symbol = null
        kind : Object = quote(java.lang.Object)

        child : Object = children#get(i)

        if(child | instanceof(Node) {
            n : Node = child | checkcast(Node)
            assert(n#getFirstChild() | instanceof(Symbol), "Invalid type declaration.")
            assert(n#getSecondChild() | instanceof(Object), "Invalid type declaration.")

            name = n#getFirstChild() | checkcast(Symbol)
            kind = n#getSecondChild()
        } else(child | instanceof(Symbol)) {
            name = child | checkcast(Symbol)
        } else {
            throw("Invalid type declaration.")
        })

        ctorInputs = vector.push(ctorInputs, quote(escape(name) : escape(kind)))
        ctorBody = vector.push(ctorBody, quote(
            assign(.(this, escape(name)), escape(name), escape(Boolean.FALSE))
        ))

        c : Class = Compiler.resolveType(kind, context)
        isStructure : boolean = DefineClass.classesAreEqual(kind, typeName, context) || (c != null && Structure#isAssignableFrom(c))

        output = vector.push(
            output
            quote(
                field(
                    name(escape(name))
                    type(escape(kind))
                    // TODO: Fix this. I want to support private fields but need to support that with DefineClass first
                    modifiers(public)
                )
            )
        )

        output = vector.push(
            output
            quote(
                method(
                    name(escape(Symbol("get_" + name#toString())))
                    outputs(escape(kind))
                    modifiers(public) {
                        return(.(this, escape(name)))
                    }
                )
            )
        )

        mutationBody : Object = null
        if(isStructure {
            mutationBody = quote({
                .(this, escape(name)) = checkcast(invokevirtual(.(this, escape(name)), copyForMutation()), escape(kind))
                return(.(this, escape(name)))
            })
        } else {
            mutationBody = quote(return(.(this, escape(name))))
        })

        output = vector.push(
            output
            quote(
                method(
                    name(escape(Symbol("get_for_mutation_" + name#toString())))
                    outputs(escape(kind))
                    modifiers(public) {
                        escape(mutationBody)
                    }
                )
            )
        )

        output = vector.push(
            output
            quote(
                method(
                    name(escape(Symbol("set_" + name#toString())))
                    outputs(escape(kind))
                    inputs(value : escape(kind))
                    modifiers(public) {
                        .(this, escape(name)) = value
                        return(value)
                    }
                )
            )
        )
    })

    ctor : Vector = vector.create(
        quote(constructor)
        quote(modifiers(public))
        quote(escape(Node.fromVector(ctorInputs)))
        quote(escape(Node.fromVector(ctorBody)))
    );

    output = vector.push(output, Node.fromVector(ctor))
    return(Node.fromVector(output))
})